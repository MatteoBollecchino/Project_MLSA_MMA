import os
import ast
import sys
import datetime

# --- CONFIGURATION ---
# The root directory to scan for code files.
PROJECT_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'Project'))
# The output file will be in the project's root, which is standard.
OUTPUT_FILE_PATH = os.path.join(PROJECT_PATH, 'requirements.txt')
IGNORE_DIRS = {'__pycache__', '.git', '.idea', 'venv', 'Datasets'}

# A list of standard library modules for Python 3.8+
STD_LIB_MODULES = {
    'abc', 'aifc', 'argparse', 'array', 'ast', 'asyncio', 'atexit', 'audioop',
    'base64', 'bdb', 'binascii', 'bisect', 'builtins', 'bz2', 'calendar', 'cgi',
    'cgitb', 'chunk', 'cmath', 'cmd', 'code', 'codecs', 'codeop', 'collections',
    'colorsys', 'compileall', 'concurrent', 'configparser', 'contextlib',
    'contextvars', 'copy', 'copyreg', 'csv', 'ctypes', 'curses', 'dataclasses',
    'datetime', 'dbm', 'decimal', 'difflib', 'dis', 'distutils', 'doctest',
    'email', 'encodings', 'ensurepip', 'enum', 'errno', 'faulthandler', 'fcntl',
    'filecmp', 'fileinput', 'fnmatch', 'fractions', 'ftplib', 'functools',
    'gc', 'getopt', 'getpass', 'gettext', 'glob', 'grp', 'gzip', 'hashlib',
    'heapq', 'hmac', 'html', 'http', 'imaplib', 'imghdr', 'imp', 'importlib',
    'inspect', 'io', 'ipaddress', 'itertools', 'json', 'keyword', 'lib2to3',
    'linecache', 'locale', 'logging', 'lzma', 'mailbox', 'mailcap', 'marshal',
    'math', 'mimetypes', 'mmap', 'modulefinder', 'multiprocessing', 'netrc',
    'nis', 'nntplib', 'numbers', 'operator', 'optparse', 'os', 'ossaudiodev',
    'parser', 'pathlib', 'pdb', 'pickle', 'pickletools', 'pipes', 'pkgutil',
    'platform', 'plistlib', 'poplib', 'posix', 'pprint', 'pty', 'pwd', 'py_compile',
    'pyclbr', 'pydoc', 'queue', 'quopri', 'random', 're', 'readline', 'reprlib',
    'resource', 'rlcompleter', 'runpy', 'sched', 'secrets', 'select', 'selectors',
    'shelve', 'shlex', 'shutil', 'signal', 'site', 'smtpd', 'smtplib', 'sndhdr',
    'socket', 'socketserver', 'spwd', 'sqlite3', 'ssl', 'stat', 'statistics',
    'string', 'stringprep', 'struct', 'subprocess', 'sunau', 'symbol', 'symtable',
    'sys', 'sysconfig', 'syslog', 'tabnanny', 'tarfile', 'telnetlib', 'tempfile',
    'termios', 'textwrap', 'threading', 'time', 'timeit', 'tkinter', 'token',
    'tokenize', 'trace', 'traceback', 'tracemalloc', 'tty', 'turtle', 'turtledemo',
    'types', 'typing', 'unicodedata', 'unittest', 'urllib', 'uu', 'uuid', 'venv',
    'warnings', 'wave', 'weakref', 'webbrowser', 'wsgiref', 'xdrlib', 'xml',
    'xmlrpc', 'zipapp', 'zipfile', 'zipimport', 'zlib'
}
# --- END CONFIGURATION ---

class ImportVisitor(ast.NodeVisitor):
    def __init__(self):
        self.imports = set()

    def visit_Import(self, node):
        for alias in node.names:
            self.imports.add(alias.name.split('.')[0])
        self.generic_visit(node)

    def visit_ImportFrom(self, node):
        if node.level == 0 and node.module:  # Absolute import
            self.imports.add(node.module.split('.')[0])
        self.generic_visit(node)

def find_third_party_imports():
    """
    Parses all Python files in the project to find third-party imports.
    """
    all_imports = set()
    for root, dirs, files in os.walk(PROJECT_PATH, topdown=True):
        dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]
        for file in files:
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                        tree = ast.parse(content, filename=file)
                        visitor = ImportVisitor()
                        visitor.visit(tree)
                        all_imports.update(visitor.imports)
                except Exception as e:
                    print(f"Warning: Could not parse {file_path}: {e}")
    
    third_party_imports = {
        name for name in all_imports if name not in STD_LIB_MODULES
    }
    return sorted(list(third_party_imports))

def main():
    """
    Main function to generate the requirements.txt file.
    """
    print("Scanning project for third-party dependencies...")
    third_party_modules = find_third_party_imports()
    
    if not os.path.isdir(PROJECT_PATH):
        print(f"Error: Project directory not found at '{PROJECT_PATH}'")
        return

    try:
        with open(OUTPUT_FILE_PATH, 'w', encoding='utf-8') as f:
            f.write(f"# requirements.txt generated by script on {datetime.datetime.now().strftime('%Y-%m-%d')}\n")
            f.write("# This is a best-effort list based on static analysis.\n")
            f.write("# Package names may differ from import names (e.g., 'sklearn' -> 'scikit-learn').\n")
            f.write("# Please review and update as necessary.\n\n")
            
            if third_party_modules:
                for module_name in third_party_modules:
                    f.write(f"{module_name.lower()}\n")
            else:
                f.write("# No third-party packages detected.\n")

        print(f"\nSuccessfully generated requirements.txt at: {OUTPUT_FILE_PATH}")
        print("\n--- Found Modules ---")
        if third_party_modules:
            for module in third_party_modules:
                print(f"- {module}")
            print("\nNOTE: Please verify package names (e.g., 'torch' is correct, but 'sklearn' should be 'scikit-learn').")
        else:
            print("No third-party modules found.")
            
    except IOError as e:
        print(f"Error writing to file: {e}")

if __name__ == '__main__':
    main()
